# Alternativas a JSON: ¿cuál elegir y cuándo?

JSON es genial por su simplicidad y ubicuidad en la web. Aun así, no siempre es la mejor opción. Aquí tienes un mapa rápido de formatos alternativos: qué son, por qué usarlos y en qué casos brillan.

---

## 1) YAML
**Qué es:** Un superconjunto legible de JSON pensado para configuración humana.

**Pros:**
- Muy legible; menos ruido visual que JSON.
- Comentarios nativos (#) y anclas/alias.

**Contras:**
- Sensible a la indentación; fácil cometer errores sutiles.
- Parsers con matices; no ideal para datos críticos en producción.

**Úsalo para:** Configuración (DevOps, CI/CD, Kubernetes), plantillas.

**Ejemplo:**
```yaml
app:
  name: tienda
  port: 8080
  features:
    - pagos
    - carritos
```

---

## 2) XML
**Qué es:** Formato de marcado extensible con esquemas (XSD) y atributos.

**Pros:**
- Esquemas sólidos, validación estricta.
- Espacios de nombres; muy usado en entornos enterprise.

**Contras:**
- Verboso; más pesado que JSON.
- Menos natural para estructuras tipo lista/objeto.

**Úsalo para:** Integraciones legacy, documentos con metadatos complejos, SOAP.

**Ejemplo:**
```xml
<app name="tienda" port="8080">
  <feature>pagos</feature>
  <feature>carritos</feature>
</app>
```

---

## 3) Protocol Buffers (Protobuf)
**Qué es:** Formato binario de Google con IDL (archivos .proto) y código generado.

**Pros:**
- Compacto y muy rápido.
- Esquema explícito con compatibilidad hacia/atrás.

**Contras:**
- No legible por humanos.
- Requiere compilación de esquemas.

**Úsalo para:** Microservicios de alto rendimiento, comunicación entre servicios, almacenamiento eficiente.

**Ejemplo (.proto):**
```proto
message Producto {
  int32 id = 1;
  string nombre = 2;
  float precio = 3;
}
```

---

## 4) Apache Avro
**Qué es:** Formato binario con esquemas JSON y fuerte enfoque en evolución de datos.

**Pros:**
- Esquemas incrustables en los ficheros (útil en data lakes).
- Muy usado en Kafka/Hadoop.

**Contras:**
- Menos extendido fuera del ecosistema data.
- Aprendizaje inicial.

**Úsalo para:** Streaming/eventos (Kafka), almacenamiento columnar/Big Data, pipelines.

---

## 5) MessagePack
**Qué es:** "JSON binario"; serializa a binario conservando la estructura de JSON.

**Pros:**
- Más compacto que JSON; rápido.
- Fácil transición desde/desde JSON.

**Contras:**
- Pierdes legibilidad humana.

**Úsalo para:** APIs móviles, IoT, redes con poco ancho de banda.

**Ejemplo (conceptual):** `{"id":1,"ok":true}` → bytes compactos MsgPack.

---

## 6) CBOR
**Qué es:** Formato binario estandarizado (RFC 8949) inspirado en JSON pero más rico (fechas, binarios, etiquetas).

**Pros:**
- Eficiente, extensible y con tipos adicionales.
- Muy usado en IoT/embedded y protocolos modernos (COSE, WebAuthn).

**Contras:**
- Requiere librerías; menor visibilidad que JSON.

**Úsalo para:** Dispositivos, seguridad, mensajes con tipos no triviales.

---

## 7) TOML
**Qué es:** Formato de configuración minimalista, clave=valor, ordenado y predecible.

**Pros:**
- Muy legible; menos ambigüedades que YAML.
- Excelente para config de apps (p. ej., `pyproject.toml`).

**Contras:**
- No ideal para datos profundos o complejos.

**Úsalo para:** Configuración de proyectos, toolchains, paquetes.

**Ejemplo:**
```toml
[app]
name = "tienda"
port = 8080
features = ["pagos", "carritos"]
```

---

## 8) CSV
**Qué es:** Texto plano tabular, separado por comas (u otros delimitadores).

**Pros:**
- Ultra simple; interoperable con Excel y BI.
- Muy eficiente para datos tabulares.

**Contras:**
- Sin tipos ni jerarquía; problemas con comillas/escapes.

**Úsalo para:** Intercambio de datos tabulares, exportaciones, análisis rápido.

**Ejemplo:**
```csv
id,nombre,precio
1,camiseta,19.99
2,zapatos,49.95
```

---

## 9) Amazon Ion
**Qué es:** JSON extendido con tipos adicionales (timestamps, decimales exactos), disponible en texto y binario.

**Pros:**
- Compatibilidad mental con JSON, pero más tipos.
- Modo binario eficiente + texto legible.

**Contras:**
- Ecosistema más de nicho.

**Úsalo para:** Finanzas, análisis donde los tipos importan (decimales exactos).

---

## 10) BSON
**Qué es:** Variante binaria tipo documento (básica en MongoDB).

**Pros:**
- Tipos como ObjectId, binarios, fechas.
- Eficiente para documentos con consultas parciales.

**Contras:**
- Acoplamiento a ecosistemas específicos.

**Úsalo para:** Aplicaciones sobre MongoDB y drivers compatibles.

---

## 11) Cap’n Proto y FlatBuffers
**Qué son:** Serializadores binarios de muy alto rendimiento, lectura sin deserialización completa (zero-copy).

**Pros:**
- Latencias bajísimas; excelente para juegos, tiempo real, móviles.

**Contras:**
- Complejidad y tooling más especializado.

**Úsalos para:** Sistemas embebidos, juegos, streaming en tiempo real.

---

## Decisión rápida
- **Config humana:** TOML (simple) o YAML (potente).  
- **APIs públicas web:** JSON (estándar de facto).  
- **Microservicios/alto rendimiento:** Protobuf, MessagePack, CBOR.  
- **Data/Streaming:** Avro (Kafka), Parquet/ORC para columnas (no cubiertos aquí).  
- **Enterprise/legacy:** XML.  
- **MongoDB:** BSON.  
- **Tipado rico legible+binario:** Ion.  
- **Tiempo real/zero-copy:** Cap’n Proto / FlatBuffers.

---

## Buenas prácticas
- **Versiona tus esquemas** (semver, campos opcionales).  
- **Evolución compatible:** evita borrar/renombrar sin alias; usa IDs numéricos en binarios.  
- **Validación** (JSON Schema, XSD, Avro schema, Protobuf).  
- **Compresión** (gzip/zstd) cuando el formato no sea binario compacto.  
- **Observabilidad:** registra tamaños, latencias, tasas de error de (de)serialización.

---

### Conclusión
No existe un "mejor" formato universal. El contexto manda: **legibilidad**, **rendimiento**, **tipado** y **ecosistema** son las cuatro variables clave. Empieza con JSON si dudas; cambia cuando tus requisitos (rendimiento, esquemas, tamaños, compatibilidad) lo justifiquen.
